---
import { PhaseName } from "@/utils/types.utils";

interface Props {
  phaseName: PhaseName;   // tu enum
  percentage: number;     // 0..100
  shadow?: boolean;
  animate?: boolean;
}

const { phaseName, percentage, shadow, animate } = Astro.props;

// Mantengo tu lógica para el “grosor” de la sombra
const isWaning = [
  PhaseName.Waning,
  PhaseName.LastQuarter,
  PhaseName.NewMoon,
].includes(phaseName);

const percentageToRender = [PhaseName.NewMoon, PhaseName.FullMoon].includes(phaseName)
  ? 50
  : Math.floor(Number(percentage) - 50) * 0.84 + 0.16;
---

<figure class="relative p-[10%] overflow-hidden w-full aspect-square stage">
  <div
    id="moon"
    class="m-auto flex justify-center items-center"
    style={`${
      shadow ? 'box-shadow: 0px 0px .2em .1em #ffffff33;' : ''
    } ${animate ? 'animation: move-map 120s infinite linear;' : 'background-position-x: 60%'}`}
  ></div>

  <!-- contenedor que rotamos dinámicamente con el ángulo real -->
  <div
    id="moon-shape"
    class:list={[
      "w-full h-full absolute top-0 left-0 will-change-transform",
      { "rotate-[-0deg]": ![PhaseName.LastQuarter, PhaseName.FirstQuarter].includes(phaseName) },
    ]}
    style="transform: rotate(0deg);"
  >
    <svg width="100%" height="100%" viewBox="0 0 100 100">
      <filter id="dropshadow" height="105%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="2.5"></feGaussianBlur>
      </filter>
      <path
        d={`M 50 1 A 49,49 0
            ${isWaning ? "0,1" : "1,0"}
            50,100 A
            ${percentageToRender},50
            0
            ${(isWaning && percentage < 50) || (!isWaning && percentage > 50) ? "0,1" : "1,0"}
            50,1`}
        stroke-width="0"
        stroke="none"
        fill="#000000F1"
        style="filter:url(#dropshadow)"
      />
    </svg>
  </div>
</figure>

<!-- Info debajo: fase, porcentaje, rise/set (dependen de ubicación) -->
<section class="info">
  <div class="row">
    <span class="phase" id="moonPhaseTxt">{String(phaseName)}</span>
    <span class="pct">| {Math.round(percentage)}%</span>
  </div>
  <div class="sub" id="moonTimes">Rise — / Set —</div>
  <div class="tiny" id="moonLocHint">Using your location if permitted.</div>
</section>

<style>
  .stage { width: 100%; display: inline-block; perspective: 400%; perspective-origin: 50% 50%; }
  #moon {
    width: 100%;
    height: 100%;
    background-image: url("/moon.webp"); /* asegúrate que exista */
    background-position-y: center;
    background-size: 250% auto;
    border-radius: 50%;
  }
  @keyframes move-map { 0% { background-position-x: -67%; } 100% { background-position-x: 100%; } }

  .info { text-align: center; margin-top: 10px; color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; }
  .row { font-size: 28px; font-weight: 800; }
  .pct { font-size: 16px; opacity: .85; margin-left: 8px; }
  .sub { margin-top: 6px; font-size: 14px; color: #a5b4fc; }
  .tiny { margin-top: 4px; font-size: 12px; color: #94a3b8; }
</style>

<script client:load>
  import SunCalc from 'suncalc';

  const shape = document.getElementById('moon-shape');
  const timesEl = document.getElementById('moonTimes');
  const hintEl  = document.getElementById('moonLocHint');

  function setRotationAndTimes(lat = 0, lon = 0) {
    const now = new Date();
    const ill = SunCalc.getMoonIllumination(now);        // { fraction, phase, angle }
    const pos = SunCalc.getMoonPosition(now, lat, lon);  // { parallacticAngle, ... }
    const angleRad = -(pos.parallacticAngle + ill.angle);
    const angleDeg = angleRad * 180 / Math.PI;

    if (shape) shape.style.transform = `rotate(${angleDeg}deg)`;

    // Rise/Set (pueden ser null en latitudes altas)
    try {
      const mt = SunCalc.getMoonTimes(now, lat, lon);
      const riseTxt = mt.rise ? new Date(mt.rise).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '—';
      const setTxt  = mt.set  ? new Date(mt.set ).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '—';
      if (timesEl) timesEl.textContent = `Rise ${riseTxt} / Set ${setTxt}`;
    } catch {
      if (timesEl) timesEl.textContent = `Rise — / Set —`;
    }
  }

  function init(lat = 0, lon = 0, usedGeo = false) {
    setRotationAndTimes(lat, lon);
    if (hintEl) hintEl.textContent = usedGeo ? 'Using your location.' : 'Using a generic orientation.';
    // refresca cada 10 min
    setInterval(() => setRotationAndTimes(lat, lon), 10 * 60 * 1000);
  }

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (pos) => init(pos.coords.latitude, pos.coords.longitude, true),
      ()    => init(), // denegado → orientación genérica
      { enableHighAccuracy: false, timeout: 6000, maximumAge: 300000 }
    );
  } else {
    init();
  }
</script>
