-import SunCalc from "suncalc";

export function initMoon() {
  const shape   = document.getElementById('moon-shape') as HTMLElement | null;
  const timesEl = document.getElementById('moonTimes') as HTMLElement | null;
  const hintEl  = document.getElementById('moonLocHint') as HTMLElement | null;
  const listEl  = document.getElementById('nextPhases') as HTMLElement | null;

  function setRotationAndTimes(lat = 0, lon = 0) {
    const now = new Date();
    const ill = SunCalc.getMoonIllumination(now);
    const pos = SunCalc.getMoonPosition(now, lat, lon);
    const angleRad = -(pos.parallacticAngle + ill.angle);
    const angleDeg = (angleRad * 180) / Math.PI;
    if (shape) shape.style.transform = `rotate(${angleDeg}deg)`;

    try {
      const mt = SunCalc.getMoonTimes(now, lat, lon);
      const riseTxt = mt.rise ? new Date(mt.rise).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '—';
      const setTxt  = mt.set  ? new Date(mt.set ).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '—';
      if (timesEl) timesEl.textContent = `Rise ${riseTxt} / Set ${setTxt}`;
    } catch {
      if (timesEl) timesEl.textContent = `Rise — / Set —`;
    }
  }

  const TARGETS = [
    { key: 'New Moon',      value: 0.0  },
    { key: 'First Quarter', value: 0.25 },
    { key: 'Full Moon',     value: 0.5  },
    { key: 'Last Quarter',  value: 0.75 },
  ] as const;

  function wrapErr(x: number) {
    x = ((x % 1) + 1) % 1;
    return x > 0.5 ? x - 1 : x;
  }

  async function findNextPhaseDates() {
    const out: { label: string; date: Date }[] = [];
    const start = new Date();

    for (const t of TARGETS) {
      let minErr = 1e9;
      let candidate = new Date(start);

      for (let d = 0; d < 60; d++) {
        const test = new Date(start.getTime() + d * 86400000);
        for (let h = 0; h < 24; h += 6) {
          const dt = new Date(test.getFullYear(), test.getMonth(), test.getDate(), h);
          const phase = SunCalc.getMoonIllumination(dt).phase;
          const err = Math.min(Math.abs(phase - t.value), 1 - Math.abs(phase - t.value));
          if (err < minErr) { minErr = err; candidate = dt; }
        }
      }

      let lo = new Date(candidate.getTime() - 36 * 3600 * 1000);
      let hi = new Date(candidate.getTime() + 36 * 3600 * 1000);
      for (let i = 0; i < 22; i++) {
        const mid = new Date((lo.getTime() + hi.getTime()) / 2);
        const phaseMid = SunCalc.getMoonIllumination(mid).phase;
        const errMid = wrapErr(phaseMid - t.value);
        const errLo  = wrapErr(SunCalc.getMoonIllumination(lo).phase - t.value);
        if (Math.abs(errLo) < Math.abs(errMid)) hi = mid; else lo = mid;
      }
      const best = new Date((lo.getTime() + hi.getTime()) / 2);
      out.push({ label: t.key, date: best });
    }
    return out.sort((a,b) => a.date.getTime() - b.date.getTime());
  }

  function renderNextPhases(list: {label:string; date:Date}[]) {
    if (!listEl) return;
    listEl.innerHTML = '';
    list.slice(0, 4).forEach(item => {
      const li = document.createElement('li');
      const label = document.createElement('span');
      label.className = 'label';
      label.textContent = item.label;
      const val = document.createElement('span');
      val.className = 'value';
      val.textContent = item.date.toLocaleString([], { month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' });
      li.appendChild(label);
      li.appendChild(val);
      listEl.appendChild(li);
    });
  }

  async function boot(lat = 0, lon = 0, usedGeo = false) {
    setRotationAndTimes(lat, lon);
    if (hintEl) hintEl.textContent = usedGeo ? 'Using your location.' : 'Using a generic orientation.';
    setInterval(() => setRotationAndTimes(lat, lon), 10 * 60 * 1000);
    const phases = await findNextPhaseDates();
    renderNextPhases(phases);
  }

  if ('geolocation' in navigator) {
    navigator.geolocation.getCurrentPosition(
      (pos) => boot(pos.coords.latitude, pos.coords.longitude, true),
      ()    => boot(),
      { enableHighAccuracy: false, timeout: 6000, maximumAge: 300000 }
    );
  } else {
    boot();
  }
}
